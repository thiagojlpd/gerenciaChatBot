<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatbot de Detona√ß√£o</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap');
        @import url('https://fonts.googleapis.com/icon?family=Material+Icons');
    
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to right, #e0f2f1, #f5f5f5);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #333;
            flex-direction: column;
        }
    
        h2 {
            font-size: 24px;
            color: #024940;
            margin-bottom: 20px;
        }
    
        #chatbox {
            width: 90cap;
            height: 420px;
            border-radius: 12px;
            background-color: #fff;
            padding: 24px;
            overflow-y: auto;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            gap: 16px;
            animation: fadeIn 0.5s ease;
        }
    
        button {
            background-image: linear-gradient(to right, #80CBC4, #68a49e);
            color: white;
            font-size: 16px;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 6px;
            margin-top: 10px;
            transition: all 0.3s ease-in-out;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }
    
        button:hover {
            background-image: linear-gradient(to right, #80CBC4, #71afa9);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
    
        button:active {
            transform: scale(0.98);
        }
    
        #userInput {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 6px;
            margin-top: 10px;
            box-sizing: border-box;
            transition: all 0.3s ease-in-out;
        }
    
        #userInput:focus {
            border-color: #00796b;
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 121, 107, 0.2);
        }
    
        .fade-in {
            animation: fadeIn 0.5s ease;
        }
    
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
    
        .user-message,
        .bot-message {
            margin-bottom: 8px;
            padding: 12px 16px;
            border-radius: 10px;
            max-width: 100%;
            word-wrap: break-word;
            backdrop-filter: blur(6px);
            background: rgba(255, 255, 255, 0.7);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
    
        .user-message {
            background-color: #80CBC4;
            color: white;
            align-self: flex-end;
            border-left: 4px solid #4db6ac;
            animation: slideInRight 0.5s ease;
        }
    
        .bot-message {
            background-color: #eeeeee;
            color: #333;
            align-self: flex-start;
            border-left: 4px solid #ccc;
            animation: slideInLeft 0.5s ease;
        }
    
        @keyframes slideInRight {
            0% {
                opacity: 0;
                transform: translateX(30px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
    
        @keyframes slideInLeft {
            0% {
                opacity: 0;
                transform: translateX(-30px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
    
        .follow-up {
            font-style: italic;
            color: #00796b;
            margin-top: 10px;
        }
    </style>
    

</head>

<body>

    <!-- Container principal do chatbot -->
    <div>
        <!-- T√≠tulo da interface do chatbot -->
        <h2>Chatbot sobre necessidades de detona√ß√£o</h2>

        <!-- √Årea onde as mensagens do chatbot e do usu√°rio ser√£o exibidas -->
        <div id="chatbox"></div>

        <!-- Campo de entrada de texto para o usu√°rio digitar perguntas -->
        <input type="text" id="userInput" placeholder="Digite sua pergunta...">

        <!-- Bot√£o que aciona a fun√ß√£o de envio da pergunta -->
        <button onclick="sendMessage()">Enviar</button>
    </div>

    <script>
        // Objeto contendo regras organizadas por categorias com perguntas e respostas
        const rules = {
            "Respons√°vel T√©cnico": {
                "Quem pode ser o respons√°vel t√©cnico pela detona√ß√£o?": "S√£o aceitos como respons√°vel t√©cnico: engenheiro de minas, engenheiro civil, ge√≥logo, t√©cnico em minera√ß√£o, que devem possuir registro no CREA /CRT.",
                "O respons√°vel t√©cnico pela detona√ß√£o deve ter v√≠nculo com a contratante ou contratada?": "O respons√°vel t√©cnico designado na autoriza√ß√£o de detona√ß√£o deve ter v√≠nculo com a empresa respons√°vel pela detona√ß√£o.",
                "Quem deve assinar a ART ou CRT?": "O respons√°vel pela ART/CRT deve ser o mesmo respons√°vel pelo servi√ßo de detona√ß√£o descrito no requerimento da autoriza√ß√£o do servi√ßo de detona√ß√£o.",
                "A ART pode ser assinada por profissional de outras regi√µes do pa√≠s (CREA MG, RJ etc.)?": "Sim, desde que ele tenha v√≠nculo com a empresa executante do servi√ßo de detona√ß√£o."
            },
            "Autoriza√ß√£o de Detona√ß√£o": {
                "Quem presta o servi√ßo de detona√ß√£o para terceiros (contratado) precisa possuir registro? E com qual atividade no registro?": "O prestador do servi√ßo de detona√ß√£o (contratado) deve possuir registro, especificamente com a atividade de 'presta√ß√£o de servi√ßo de detona√ß√£o'.",
                "Quem contrata o servi√ßo de detona√ß√£o precisa possuir registro? E com qual atividade no registro?": "Quem contrata o servi√ßo (contratante) precisa ter registro com a atividade 'utiliza√ß√£o - aplica√ß√£o de explosivos' (somente de forma terceirizada)."
            },
            "Autoriza√ß√£o para Aquisi√ß√£o de Explosivos": {
                "Quando deve ser requerida a 'autoriza√ß√£o para aquisi√ß√£o de explosivos'?": "A 'autoriza√ß√£o para aquisi√ß√£o de explosivos' deve ser solicitada, e se faz necess√°ria sempre que houver a aquisi√ß√£o dos explosivos classificados nos grupos de ordem 3.1, 3.3 e 3.4.",
                "O que √© necess√°rio para requerer a 'autoriza√ß√£o para aquisi√ß√£o de explosivos'?": "Para a aquisi√ß√£o de explosivos, √© necess√°rio registro com atividade que pressuponha a aquisi√ß√£o e com a atividade de armazenamento apostilada."
            },
            "Teoria dos Quart√™nios": {
                // Diversas perguntas e respostas sobre o tema "quart√™nios"
                "O que √© a teoria dos quart√™nios?": "A teoria dos quart√™nios √© um conceito matem√°tico que envolve a utiliza√ß√£o de n√∫meros chamados 'quart√™nios'...",
                // (demais perguntas omitidas aqui para brevidade, mas seguem o mesmo padr√£o)
            }
        };

        // Vari√°vel para controlar se o chatbot est√° exibindo sugest√µes de t√≥picos (inicialmente n√£o)
        bestMatchTwoZeroResponse = 0;
        let showingTopics = false;

        // Fun√ß√£o para listar os t√≥picos dispon√≠veis (categorias)
        function listTopics() {
            let message = "<strong>Lista de t√≥picos dispon√≠veis:</strong><br>";
            let index = 1;

            // Loop por todas as categorias do objeto 'rules'
            for (const category in rules) {
                message += `${index}. ${category}<br>`; // Adiciona o nome do t√≥pico √† mensagem
                index++;
            }

            // Instru√ß√£o adicional para o usu√°rio escolher o n√∫mero do t√≥pico
            message += `<div class="follow-up">Digite o n√∫mero do t√≥pico desejado para ver as perguntas e respostas correspondentes.</div>`;

            // Define que o chatbot est√° mostrando os t√≥picos
            showingTopics = true;

            // Retorna a mensagem formatada com os t√≥picos
            return message;
        }

        // Fun√ß√£o para exibir as perguntas e respostas de um t√≥pico espec√≠fico, com base no n√∫mero escolhido pelo usu√°rio
        function showQuestionsByTopic(index) {
            const categories = Object.keys(rules); // Lista todas as categorias (t√≥picos)
            const topicIndex = parseInt(index, 10) - 1; // Converte o √≠ndice recebido para n√∫mero inteiro

            // Verifica se o √≠ndice informado √© v√°lido
            if (isNaN(topicIndex) || topicIndex < 0 || topicIndex >= categories.length) {
                return "N√∫mero inv√°lido. Por favor, escolha um dos n√∫meros listados.";
            }

            // Recupera a categoria selecionada com base no √≠ndice
            const selectedCategory = categories[topicIndex];
            const questions = rules[selectedCategory]; // Objeto com perguntas e respostas do t√≥pico selecionado
            let message = `<strong>${selectedCategory}:</strong><br>`;

            // Adiciona cada pergunta e resposta na mensagem
            for (const question in questions) {
                message += `<br><strong>Q:</strong> ${question}<br><strong>R:</strong> ${questions[question]}<br>`;
            }

            // Marca que n√£o est√° mais exibindo os t√≥picos e reseta controle
            showingTopics = false;
            bestMatchTwoZeroResponse = 0;

            // Retorna mensagem com perguntas e respostas do t√≥pico selecionado
            return message;
        }

        /**
     * Calcula a dist√¢ncia de Levenshtein entre duas palavras.
     * Essa m√©trica mede o n√∫mero m√≠nimo de opera√ß√µes (inser√ß√µes, dele√ß√µes e substitui√ß√µes)
     * necess√°rias para transformar uma string na outra.
     */
        function levenshteinDistance(a, b) {
            // Cria uma matriz (tabela) com dimens√µes [a.length+1][b.length+1] preenchida com zeros
            const matrix = Array.from({ length: a.length + 1 }, (_, i) => Array(b.length + 1).fill(0));

            // Inicializa a primeira coluna da matriz com valores crescentes (0 a a.length)
            for (let i = 0; i <= a.length; i++) matrix[i][0] = i;

            // Inicializa a primeira linha da matriz com valores crescentes (0 a b.length)
            for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

            // Preenche o restante da matriz com base na compara√ß√£o dos caracteres
            for (let i = 1; i <= a.length; i++) {
                for (let j = 1; j <= b.length; j++) {
                    // Define o custo: 0 se os caracteres forem iguais, 1 se diferentes
                    const cost = a[i - 1] === b[j - 1] ? 0 : 1;

                    // Calcula o valor m√≠nimo entre: remo√ß√£o, inser√ß√£o ou substitui√ß√£o
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,       // Remo√ß√£o
                        matrix[i][j - 1] + 1,       // Inser√ß√£o
                        matrix[i - 1][j - 1] + cost // Substitui√ß√£o
                    );
                }
            }

            // Retorna a dist√¢ncia de Levenshtein entre as duas palavras
            return matrix[a.length][b.length];
        }

        /**
         * Extrai palavras-chave de uma string removendo espa√ßos e convertendo para min√∫sculas.
         * Apenas palavras com mais de 2 caracteres s√£o consideradas.
         */
        function extractKeywords(text) {
            // Converte para min√∫sculas, divide por espa√ßo e filtra palavras com mais de 2 letras
            return text.toLowerCase().split(" ").filter(word => word.length > 2);
        }

        /**
         * Encontra a melhor correspond√™ncia para a pergunta do usu√°rio.
         * Utiliza a dist√¢ncia de Levenshtein para permitir pequenos erros de digita√ß√£o.
         */
        function findBestMatch(userText) {
            // Extrai palavras-chave da pergunta do usu√°rio
            const userKeywords = extractKeywords(userText);

            // Inicializa a melhor correspond√™ncia encontrada
            let bestMatch = { question: "", answer: "", score: 0 };

            // Percorre todas as categorias de perguntas no objeto rules
            for (const category in rules) {
                // Percorre cada pergunta dentro da categoria
                for (const question in rules[category]) {
                    // Extrai palavras-chave da pergunta cadastrada
                    const questionKeywords = extractKeywords(question);
                    let score = 0;

                    // Compara cada palavra-chave digitada com cada palavra da pergunta cadastrada
                    userKeywords.forEach(userWord => {
                        questionKeywords.forEach(questionWord => {
                            // Calcula a dist√¢ncia de Levenshtein entre as palavras
                            const distance = levenshteinDistance(userWord, questionWord);

                            // Se forem iguais ou semelhantes (dist√¢ncia <= 2 e palavra com mais de 3 letras), aumenta o score
                            if (distance === 0 || (distance <= 2 && questionWord.length > 3)) {
                                score++;
                            }
                        });
                    });

                    // Atualiza o melhor match se o score atual for maior
                    if (score > bestMatch.score) {
                        bestMatch = {
                            question: question,
                            answer: rules[category][question],
                            score: score
                        };
                    }
                }
            }

            // Retorna a melhor correspond√™ncia encontrada
            return bestMatch;
        }

        /**
         * Envia a mensagem quando o usu√°rio pressiona "Enter".
         */
        function handleKeyPress(event) {
            // Se a tecla pressionada for "Enter"
            if (event.key === "Enter") {
                sendMessage(); // Envia a mensagem
            }
        }

        // Adiciona um ouvinte de evento ao campo de entrada para detectar pressionamento da tecla Enter
        document.getElementById("userInput").addEventListener("keypress", handleKeyPress);

        /**
         * Fun√ß√£o para obter uma sauda√ß√£o com base no hor√°rio do dia.
         * Exemplo: "Bom dia", "Boa tarde" ou "Boa noite".
         */
        function getGreeting() {
            const hour = new Date().getHours(); // Obt√©m a hora atual (0‚Äì23)

            // Retorna a sauda√ß√£o apropriada de acordo com a hora
            if (hour < 12) {
                return "Bom dia";
            } else if (hour < 18) {
                return "Boa tarde";
            } else {
                return "Boa noite";
            }
        }



        /**
  * Fun√ß√£o que retorna uma mensagem de boas-vindas aleat√≥ria.
  * Existem v√°rias op√ß√µes de mensagens para dar a impress√£o de intera√ß√µes diferentes.
  */
        function getRandomWelcomeMessage() {
            // Lista de mensagens de boas-vindas
            const welcomeMessages = [
                "Como posso te ajudar hoje?",
                "Tudo bem? Como posso ser √∫til para voc√™?",
                "Seja bem-vindo! O que posso fazer por voc√™?",
                "Como posso te ajudar neste dia?",
                "Em que posso te ajudar hoje?",
                "Como posso te ajudar? Estou aqui para isso!",
                "O que posso fazer por voc√™?",
                "Bem-vindo ao nosso chat! Como posso te auxiliar?",
                "Como posso ajudar voc√™ com suas d√∫vidas?",
                "Em que posso ser √∫til para voc√™ hoje?"
            ];

            // Retorna uma das mensagens aleatoriamente
            return welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
        }

        /**
         * Fun√ß√£o que exibe a sauda√ß√£o de boas-vindas assim que a p√°gina √© carregada.
         * Inclui uma sauda√ß√£o com base no hor√°rio do dia.
         */
        function displayWelcomeMessage() {
            const chatbox = document.getElementById("chatbox"); // Obt√©m a √°rea do chat
            const greeting = getGreeting(); // Obt√©m a sauda√ß√£o de acordo com o hor√°rio
            const randomMessage = getRandomWelcomeMessage(); // Obt√©m uma mensagem aleat√≥ria
            const welcomeMessage = `${greeting}! ${randomMessage}`; // Combina sauda√ß√£o e mensagem

            // Adiciona a mensagem de boas-vindas ao chat
            chatbox.innerHTML += `<div class="bot-message">ü§ñ <strong>Bot:</strong> ${welcomeMessage}</div>`;
            chatbox.scrollTop = chatbox.scrollHeight; // Rola o chat at√© a √∫ltima mensagem
            document.getElementById("userInput").focus(); // Coloca o foco na caixa de entrada
        }

        // Exibe a mensagem de boas-vindas quando a p√°gina for carregada
        window.onload = displayWelcomeMessage;

        /**
         * Fun√ß√£o que sanitiza a entrada do usu√°rio, evitando execu√ß√£o de c√≥digo HTML.
         */
        function sanitizeInput(input) {
            const div = document.createElement('div'); // Cria elemento tempor√°rio
            div.textContent = input; // Define o texto puro (sem HTML)
            return div.innerHTML; // Retorna o texto com caracteres escapados
        }

        /**
         * Fun√ß√£o principal que envia a mensagem digitada pelo usu√°rio.
         */
        function sendMessage() {
            const inputField = document.getElementById("userInput"); // Obt√©m o campo de entrada do usu√°rio
            const chatbox = document.getElementById("chatbox"); // Obt√©m a √°rea do chat
            let userText = inputField.value.trim(); // Remove espa√ßos antes/depois da mensagem

            if (!userText) return; // Se a mensagem estiver vazia, n√£o faz nada

            userText = sanitizeInput(userText); // Sanitiza o texto para seguran√ßa

            // Cria um ID aleat√≥rio para a mensagem do usu√°rio
            var numeroAleatorioUserMessage = Math.floor(Math.random() * 10000);

            // Cria um novo elemento de mensagem do usu√°rio
            const userMessageDiv = document.createElement('div');
            userMessageDiv.id = numeroAleatorioUserMessage; // Atribui ID √∫nico
            userMessageDiv.classList.add('user-message'); // Define a classe CSS
            userMessageDiv.innerHTML = `üßë‚Äçüè´ <strong>Voc√™:</strong> ${userText}`; // Conte√∫do da mensagem
            chatbox.appendChild(userMessageDiv); // Adiciona a mensagem ao chat

            let botResponse = ""; // Resposta do bot
            let followUpText = ""; // Texto adicional explicativo

            // Verifica se o usu√°rio est√° visualizando t√≥picos e digitou um n√∫mero
            if (showingTopics && /^\d+$/.test(userText)) {
                botResponse = showQuestionsByTopic(userText); // Mostra perguntas do t√≥pico
            } else {
                const bestMatch = findBestMatch(userText); // Encontra a melhor pergunta correspondente

                if (bestMatch.score > 0) {
                    botResponse = bestMatch.answer; // Usa a resposta correspondente
                    followUpText = `Caso esteja se referindo √† pergunta: <em>"${bestMatch.question}"</em>.`; // Texto de apoio
                    bestMatchTwoZeroResponse = 0; // Reinicia o contador de respostas sem correspond√™ncia
                } else {
                    bestMatchTwoZeroResponse++; // Incrementa contador de respostas vazias
                    botResponse = "Desculpe, n√£o tenho uma resposta para essa pergunta. Por favor, pergunte-me sobre assuntos relacionados ou, se preferir, envie-nos uma mensagem atrav√©s de nosso e-mail üí° 'Fale Conosco'.";

                    // Se for a segunda vez consecutiva sem resposta, mostra os t√≥picos dispon√≠veis
                    if (bestMatchTwoZeroResponse >= 2) {
                        botResponse += "<br><br>" + listTopics();
                    }
                }
            }

            // Cria um ID aleat√≥rio para a mensagem do bot
            var numeroAleatorioBotMessage = Math.floor(Math.random() * 10000);

            // Cria o elemento de resposta do bot
            const botMessageDiv = document.createElement('div');
            botMessageDiv.id = numeroAleatorioBotMessage; // Atribui ID √∫nico
            botMessageDiv.classList.add('bot-message'); // Define a classe CSS
            botMessageDiv.innerHTML = `ü§ñ <strong>Bot:</strong> ${followUpText} ${botResponse} <br>`; // Conte√∫do da resposta
            chatbox.appendChild(botMessageDiv); // Adiciona a resposta ao chat

            chatbox.scrollTop = chatbox.scrollHeight; // Rola o chat at√© a √∫ltima mensagem
            inputField.value = ""; // Limpa o campo de entrada

            // Remove a anima√ß√£o ap√≥s 1 segundo
            setTimeout(() => {
                var lastUserMessageDiv = document.getElementById(`${numeroAleatorioUserMessage}`);
                var lastBotMessageDiv = document.getElementById(`${numeroAleatorioBotMessage}`);
                lastUserMessageDiv.classList.remove("fade-in"); // Remove a anima√ß√£o da mensagem do usu√°rio
                lastBotMessageDiv.classList.remove("fade-in"); // Remove a anima√ß√£o da resposta do bot
            }, 1000);
        }


    </script>
</body>

</html>